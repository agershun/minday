// Generated by CoffeeScript 1.3.3
﻿;

var backFlag, backHistory, childkind, childsd, downnext, editenter, history, ideaClick, saveHistory;

editenter = {};

downnext = {};

childkind = {};

childsd = {};

childkind[IDEA] = function() {
  return IDEA;
};

Idea.prototype.childkind = function() {
  var _ref, _ref1;
  if (childkind[this.kind] != null) {
    return (_ref = childkind[this.kind]) != null ? _ref.call(this) : void 0;
  } else {
    return (_ref1 = childkind[IDEA]) != null ? _ref1.call(this) : void 0;
  }
};

Idea.prototype.downnext = function() {
  var _ref, _ref1;
  if (downnext[this.kind] != null) {
    return (_ref = downnext[this.kind]) != null ? _ref.call(this) : void 0;
  } else {
    return (_ref1 = downnext[DEFAULT]) != null ? _ref1.call(this) : void 0;
  }
};

keyp[DEFAULT][ALT + KEY_LEFT] = function() {
  var ia, ix, pa, sd;
  if (this !== fidea) {
    if (this.pa[this.sd][this.ix - 1] != null) {
      ia = this;
      sd = this.sd;
      pa = this.pa;
      ix = this.ix;
      pa[sd].splice(ix, 1);
      pa[sd].splice(ix - 1, 0, ia);
      pa.normalizeIdea();
      return redraw(ia);
    }
  }
};

keyp[DEFAULT][ALT + KEY_RIGHT] = function() {
  var ia, ix, pa, sd;
  if (this !== fidea) {
    if (this.pa[this.sd][this.ix + 1] != null) {
      ia = this;
      sd = this.sd;
      pa = this.pa;
      ix = this.ix;
      pa[sd].splice(ix, 1);
      pa[sd].splice(ix + 1, 0, ia);
      pa.normalizeIdea();
      return redraw(ia);
    }
  }
};

keyp[DEFAULT][ALT + KEY_DOWN] = function() {
  var ia, ia2, ix, pa, sd;
  if (this !== fidea) {
    if (this.pa[this.sd + 1][this.ix] != null) {
      ia = this;
      sd = this.sd;
      pa = this.pa;
      ix = this.ix;
      ia2 = this.pa[this.sd + 1][this.ix];
      pa[sd + 1][ix] = ia;
      pa[sd][ix] = ia2;
      pa.normalizeIdea();
      return redraw(ia);
    }
  }
};

keyp[DEFAULT][ALT + KEY_UP] = function() {
  var ia, ia2, ix, pa, sd;
  if (this !== fidea) {
    if (this.pa[this.sd - 1][this.ix] != null) {
      ia = this;
      sd = this.sd;
      pa = this.pa;
      ix = this.ix;
      ia2 = this.pa[this.sd - 1][this.ix];
      pa[sd - 1][ix] = ia;
      pa[sd][ix] = ia2;
      pa.normalizeIdea();
      return redraw(ia);
    }
  }
};

/*
keyp[DEFAULT][ALT+KEY_DOWN] =->
#altdown[IDEA] = ->
	if @ isnt fidea and @pa.length > 1 and @ix < @pa.length-1
		ix = @ix
		ia = @pa[ix+1]
		@pa[ix+1] = @
		@pa[ix] = ia
		@pa[ix].ix = ix 
		@pa[ix+1].ix = ix+1
	@ 

keyp[DEFAULT][ALT+KEY_UP] =->
#altup[IDEA] = ->
	if @ isnt fidea and @pa.length > 1 and @ix > 0
		ix = @ix
		ia = @pa[ix-1]
		@pa[ix-1] = @
		@pa[ix] = ia
		@pa[ix].ix = ix 
		@pa[ix-1].ix = ix-1
	@ 

keyp[DEFAULT][ALT+KEY_LEFT] =->
#altleft[IDEA] = ->
	if @ isnt fidea and @pa isnt fidea
		if @frame? and @ix isnt @pa.length-1 then return @	# Если это фрейм, то можно переносить только последний элемент
																				# Чтобы не переносить детей
		ia = @
		iapa = @pa
		iapapa = @pa.pa
		ix = @ix
		paix = @pa.ix

		# Освобождаем место под текущую идею сверху
		if paix < iapapa.length-1
			for i in [iapapa.length-1..paix+1] by -1
				iapapa[i+1] = iapapa[i]
				iapapa[i+1].ix = i+1
				iapapa[i+1].pa = iapapa
		iapapa.length++

		# Берем форматирование из предыдущего элемента
		iapapa[paix+1] = ia
		ia.pa = iapapa
		ia.ix = paix+1
		if iapapa[paix]?
			if iapapa[paix].plain? then ia.plain = iapapa[paix].plain else delete ia.plain
			if iapapa[paix].list? then ia.list = iapapa[paix].list else delete ia.list

		# Переносим оставшиеся элементы как дочерние в текущий элемент
		if ix < iapa.length-1
			j = ia.length
			for i in [ix+1..iapa.length-1]
				ia[j]=iapa[i]
				ia[j].pa = ia
				ia[j].ix = j
				j++
				iapa[i] = null
				delete iapa[i]
			ia.length = j
		iapa.length = ix
	@

keyp[DEFAULT][ALT+KEY_RIGHT] =->
#altright[IDEA] = ->
	if @ isnt fidea 
		if @ix > 0 and not @pa[@ix-1].frame? # Мы не переносим первый элемент, так как он и так уже дочерний
			ix = @ix
			mia = @pa[@ix-1] 	# Предыдущий элемент, под который мы переносим текущий
			j = mia.length 		# Позиция для элемента
			pa = @pa

			# Копируем форматирование у последноего дочернего элемента предыдущего элемента
			if mia[j-1]?
				if mia[j-1].plain? then @plain = mia[j-1].plain else delete @plain
				if mia[j-1].list? then @list = mia[j-1].list else delete @list

			# Переносим элемент
			mia[j] = @
			@.pa = mia
			@.ix = j
			mia.length++
			j++

			# Теперь решаем, что делать с хвостом...
			if ix < pa.length-1
				for i in [ix..pa.length-2]
					pa[i] = pa[i+1]
					pa[i].ix = i
			pa.length--

			# Делаем дочерние элементы - дочерними элементами предыдущего
			if @length > 0 
				for i in [0..@length-1]
					mia[j] = @[i]
					mia[j].pa = mia
					mia[j].ix = j
					mia.length++
					j++
					delete @[i]
				@length = 0
	@

# TODO: Разобраться, нужны ли эти процедуры

Idea::top = () ->
	if @[TOP]?[0]? then @[TOP][0].top() else @

Idea::bottom = ->
	if @[BOTTOM]?[@[BOTTOM].length-1]? then @[BOTTOM][@[BOTTOM].length-1].bottom()
	else if @length > 0 and @[@length-1]?[0]? then @[@length-1][0].bottom()
	else if @[INSIDE]?[@[INSIDE].length-1]? then @[INSIDE][@[INSIDE].length-1].bottom()
	else @
*/


downnext[DEFAULT] = function() {
  var _ref, _ref1;
  if (this === fidea) {
    return null;
  }
  if (this.pa != null) {
    if (this.pa.intype === TABLE) {
      return this.tbxDown();
    } else if (((_ref = this.pa[this.sd + 1]) != null ? _ref[this.ix] : void 0) != null) {
      return this.pa[this.sd + 1][this.ix];
    } else if (((_ref1 = this.pa[this.sd + 1]) != null ? _ref1[this.pa[this.sd + 1].length - 1] : void 0) != null) {
      return this.pa[this.sd + 1][this.pa[this.sd + 1].length - 1];
    } else {
      return this.pa.downnext();
    }
  }
  return this;
};

keyp[DEFAULT][KEY_DOWN] = function() {
  var dnn, _ref, _ref1;
  if (sidea === fidea) {
    if (((_ref = this[0]) != null ? _ref[0] : void 0) != null) {
      return this[0][0].select();
    } else {
      return this;
    }
  } else {
    if (!(this.frame != null) && (((_ref1 = this[0]) != null ? _ref1[0] : void 0) != null)) {
      return this[0][0].select();
    } else if ((dnn = this.downnext()) != null) {
      return dnn.select();
    }
  }
  return this;
};

Idea.prototype.bottommost = function() {
  var _ref, _ref1;
  if (this.frame != null) {
    return this;
  } else if (((_ref = this[this.length - 1]) != null ? _ref[0] : void 0) != null) {
    return (_ref1 = this[this.length - 1]) != null ? _ref1[0].bottommost() : void 0;
  } else {
    return this;
  }
};

keyp[DEFAULT][KEY_UP] = function() {
  var up, _ref;
  if (sidea === fidea) {
    return this;
  } else {
    if (this.sd >= 0) {
      if (this.pa.intype === TABLE && ((up = this.tbxUp()) != null)) {
        return up.select();
      } else if (((_ref = this.pa[this.sd - 1]) != null ? _ref[this.ix] : void 0) != null) {
        return this.pa[this.sd - 1][this.ix].bottommost().select();
      } else if (this.pa[this.sd - 1] != null) {
        return this.pa[this.sd - 1][this[this.sd - 1].length - 1].bottommost().select();
      } else {
        return this.pa.select();
      }
    } else {
      if (this.pa.pa != null) {
        return this.pa.pa.select();
      }
    }
  }
  return this;
};

Idea.prototype.bottomrightmost = function() {
  if (this.length > 0) {
    return this[this.length - 1][this[this.length - 1].length - 1].bottomrightmost();
  } else {
    return this;
  }
};

keyp[DEFAULT][KEY_LEFT] = function() {
  var _ref, _ref1;
  if (this === fidea) {
    return this;
  } else if (this.pa.intype === TABLE) {
    return this.tbxLeft().select();
  } else if (this.sd === 0 && this.ix === 0) {
    return this.pa.select();
  } else if (this.sd >= 0) {
    if (((_ref = this.pa[this.sd]) != null ? _ref[this.ix - 1] : void 0) != null) {
      return this.pa[this.sd][this.ix - 1].select();
    } else if (((_ref1 = this.pa[this.sd - 1]) != null ? _ref1[this.pa[this.sd - 1].length - 1] : void 0) != null) {
      return this.pa[this.sd - 1][this.pa[this.sd - 1].length - 1].bottomrightmost().select();
    } else {
      return this.pa.select();
    }
  } else {
    return this.pa.select();
  }
  return this;
};

Idea.prototype.rightnext = function() {
  var rn, _ref, _ref1;
  if (this.pa != null) {
    if (this.pa.intype === TABLE && ((rn = this.tbxRight()) != null)) {
      return rn;
    } else if (((_ref = this.pa[this.sd]) != null ? _ref[this.ix + 1] : void 0) != null) {
      return this.pa[this.sd][this.ix + 1];
    } else if (((_ref1 = this.pa[this.sd + 1]) != null ? _ref1[0] : void 0) != null) {
      return this.pa[this.sd + 1][0];
    } else if (this.pa[this.sd + 1] != null) {
      return this.pa[this.sd + 1][this.pa[this.sd + 1].length - 1];
    } else {
      return this.pa.rightnext();
    }
  }
  return null;
};

Idea.prototype.leftnext = function() {
  var rn, _ref, _ref1;
  if (this.pa != null) {
    if (this.pa.intype === TABLE && ((rn = this.tbxLeft()) != null)) {
      return rn;
    } else if (((_ref = this.pa[this.sd]) != null ? _ref[this.ix - 1] : void 0) != null) {
      return this.pa[this.sd][this.ix - 1];
    } else if (((_ref1 = this.pa[this.sd - 1]) != null ? _ref1[0] : void 0) != null) {
      return this.pa[this.sd - 1][0];
    } else if (this.pa[this.sd - 1] != null) {
      return this.pa[this.sd + 1][this.pa[this.sd - 1].length - 1];
    } else {
      return this.pa.leftnext();
    }
  }
  return this;
};

keyp[DEFAULT][KEY_RIGHT] = function() {
  var rn, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
  if (this === fidea) {
    if (((_ref = this[0]) != null ? _ref[0] : void 0) != null) {
      return this[0][0].select();
    } else {
      return this;
    }
  } else if (this.pa.intype === TABLE && ((rn = this.tbxRight()) != null)) {
    return rn.select();
  } else if (((_ref1 = this.pa[this.sd]) != null ? _ref1[this.ix + 1] : void 0) != null) {
    return this.pa[this.sd][this.ix + 1].select();
  } else if (((_ref2 = this[0]) != null ? _ref2[0] : void 0) != null) {
    return this[0][0].select();
  } else if (this.sd >= 0) {
    if (((_ref3 = this.pa[this.sd]) != null ? _ref3[this.ix + 1] : void 0) != null) {
      return this.pa[this.sd][this.ix + 1].select();
    } else if (((_ref4 = this.pa[this.sd + 1]) != null ? _ref4[0] : void 0) != null) {
      return this.pa[this.sd + 1][0].select();
    } else if (this.pa.rightnext() != null) {
      return this.pa.rightnext().select();
    }
  } else if (((_ref5 = this[0]) != null ? _ref5[0] : void 0) != null) {
    return this[0][0].select();
  }
  return this;
};

/*
#down[IDEA] = ->
#	if (sidea is fidea) or not @frame? and @length > 0
#		return @[0]
#	else if @list? and @list is SPAN and @pa[@ix+1]?
#		if @pa[@ix+1].list? and @pa[@ix].list is SPAN
#			return down[IDEA].call(@pa[@ix+1])
		else
			return @pa[@ix+1]
	else 
		ria = @downnext()
		if ria is null then return @
		else return ria
	@


#up[IDEA] = -> keyp[DEFAULT][KEY_UP].call(@)

#	keyp[DEFAULT][KEY_UP] = -> 
up[IDEA] = ->
	unless sidea is fidea
		if @list? and (@list is SPAN or @list is TD or @list is TH) then return @pa
		if @pa?
			if @ix > 0
				ret = @pa[@ix-1].uplast()
				if ret.kind is CELL then return ret.pa[0]  # Специальная поправка для матрицы
				return ret
			else
				return @pa
	@
*/


Idea.prototype.uplast = function() {
  if (!this.frame && this.length > 0) {
    return this[this.length - 1].uplast();
  }
  return this;
};

/*
left[IDEA] = ->
	unless sidea is fidea
#		if @list? and @list is SPAN then return @pa
		if @pa?
			if @ix > 0
				ret = @pa[@ix-1].uplast()
				if ret.kind is CELL then return ret.pa[0]  # Специальная поправка для матрицы
				return ret
			else
				return @pa
	@

right[IDEA] = ->
	if (sidea is fidea) or not @frame? and @length > 0
		return @[0]
#	else if @list? and @list is SPAN
#		ria = @pa.downnext()
#		if ria is null then return @
#		else return ria
	else 
		ria = @downnext()
		if ria is null then return @
		else return ria
	@

enter[IDEA] = ->
	keyp[DEFAULT][KEY_ENTER].call(@)  # TODO: Удалить потом


tab[IDEA] =-> 
	# TODO: Ничего не делать, может быть потом создавать матрицу
*/


editenter[IDEA] = function() {
  return keye[DEFAULT][KEY_ENTER].call(this);
};

editenter[DEFAULT] = function() {
  return finishEdit();
};

keyp[DEFAULT][KEY_F2] = function() {
  if ($txt.attr("contentEditable") === "true") {
    return finishEdit();
  } else {
    if (!(sidea.readonly != null)) {
      if (!(sidea.pa != null) || !(sidea.pa.childreadonly != null)) {
        return startEdit();
      }
    }
  }
};

keyp[DEFAULT][KEY_F2] = function() {
  return editText();
};

keyp[DEFAULT][KEY_F3] = function() {
  return editForma();
};

keyp[DEFAULT][SHIFT + KEY_F3] = function() {
  return editScheme();
};

keyp[DEFAULT][ALT + KEY_F3] = function() {
  return editPlace();
};

keyp[DEFAULT][KEY_F4] = function() {
  return editKind();
};

keyp[DEFAULT][SHIFT + KEY_F4] = function() {
  return editKindReverse();
};

keyp[DEFAULT][KEY_TAB] = function() {
  return insertRightIdea();
};

keyp[DEFAULT][CTRL + KEY_TAB] = function() {
  return insertRightIdea();
};

keyp[DEFAULT][SHIFT + KEY_TAB] = function() {
  return insertLeftIdea();
};

keyp[DEFAULT][SHIFT + KEY_ENTER] = function() {
  return insertUpIdea();
};

keyp[DEFAULT][CTRL + KEY_ENTER] = function() {
  return insertDownIdea();
};

keyp[DEFAULT][SHIFT + ALT + TAB] = function() {
  return insertLeftColumn();
};

keyp[DEFAULT][CTRL + ALT + TAB] = function() {
  return insertRightColumn();
};

keyp[DEFAULT][SHIFT + ALT + KEY_ENTER] = function() {
  return insertUpRow();
};

keyp[DEFAULT][CTRL + ALT + KEY_ENTER] = function() {
  return insertDownRow();
};

keyp[DEFAULT][KEY_INSERT] = function() {
  return insertChildIdea();
};

keyp[DEFAULT][ALT + KEY_INSERT] = function() {
  return insertAltChildIdea();
};

keyp[DEFAULT][SHIFT + KEY_INSERT] = function() {
  return insertBeforeIdea();
};

keyp[DEFAULT][CTRL + KEY_INSERT] = function() {
  return insertAfterIdea();
};

keyp[DEFAULT][KEY_DELETE] = function() {
  return deleteIdeas();
};

keyp[DEFAULT][SHIFT + KEY_DELETE] = function() {
  return sidea.deleteRow();
};

keyp[DEFAULT][ALT + KEY_DELETE] = function() {
  return sidea.deleteColumn();
};

keyp[DEFAULT][CTRL + KEY_1] = function() {
  return formatSpan();
};

keyp[DEFAULT][CTRL + KEY_2] = function() {
  return formatTH();
};

keyp[DEFAULT][CTRL + KEY_3] = function() {
  return formatTD();
};

keyp[DEFAULT][CTRL + KEY_4] = function() {
  return formatSticker();
};

keyp[DEFAULT][CTRL + KEY_0] = function() {
  return editDuplicate();
};

keyp[DEFAULT][CTRL + KEY_B] = function() {
  return formatBold();
};

keyp[DEFAULT][CTRL + KEY_C] = function() {
  return editCopy();
};

keyp[DEFAULT][CTRL + KEY_F] = function() {
  return editFind();
};

keyp[DEFAULT][CTRL + KEY_I] = function() {
  return formatItalic();
};

keyp[DEFAULT][CTRL + KEY_N] = function() {
  return fileNew();
};

keyp[DEFAULT][CTRL + KEY_O] = function() {
  return fileOpen();
};

keyp[DEFAULT][CTRL + KEY_S] = function() {
  return fileSave();
};

keyp[DEFAULT][CTRL + KEY_U] = function() {
  return formatUnderline();
};

keyp[DEFAULT][CTRL + KEY_V] = function() {
  return editPaste();
};

keyp[DEFAULT][CTRL + KEY_X] = function() {
  return editCut();
};

keyp[DEFAULT][CTRL + KEY_Z] = function() {
  return editUndo();
};

keyp[DEFAULT][CTRL + KEY_Y] = function() {
  return editRedo();
};

keyp[DEFAULT][CTRL + SHIFT + KEY_ENTER] = function() {
  return insertBeforeIdea();
};

keyp[DEFAULT][ALT + KEY_ENTER] = function() {
  return formatFrame();
};

keyp[DEFAULT][ALT + KEY_C] = function() {
  return formatCheckbox();
};

keyp[DEFAULT][ALT + KEY_E] = function() {
  return textCenter();
};

keyp[DEFAULT][ALT + KEY_L] = function() {
  return formatLineThrough();
};

keyp[DEFAULT][ALT + KEY_O] = function() {
  return formatOL();
};

keyp[DEFAULT][ALT + KEY_P] = function() {
  return formatPlain();
};

keyp[DEFAULT][ALT + KEY_R] = function() {
  return formatReadOnly();
};

keyp[DEFAULT][ALT + KEY_U] = function() {
  return formatUL();
};

keyp[DEFAULT][ALT + KEY_Y] = function() {
  return formatYesNo();
};

keyp[DEFAULT][CTRL + ALT + KEY_B] = function() {
  return insertTabs();
};

keyp[DEFAULT][CTRL + ALT + KEY_D] = function() {
  return formatBorder();
};

keyp[DEFAULT][CTRL + ALT + KEY_I] = function() {
  return insertMindmap();
};

keyp[DEFAULT][CTRL + ALT + KEY_G] = function() {
  return insertGantt();
};

keyp[DEFAULT][CTRL + ALT + KEY_M] = function() {
  return insertMatrix();
};

keyp[DEFAULT][CTRL + ALT + KEY_W] = function() {
  return insertTree();
};

keyp[DEFAULT][KEY_ENTER] = function() {
  var gia, ia, _ref, _ref1, _ref2;
  if (this.run != null) {
    if (typeof this.run === "string") {
      return eval(this.run);
    } else if (typeof this.run === "function") {
      this.run.call(this);
    }
  }
  if (this === idea[0] && this.length === 0) {
    if (!((this.noenter != null) || (this.readonly != null) || (((_ref = this.pa) != null ? _ref.childreadonly : void 0) != null))) {
      if (prevKey === KEY_ENTER) {
        return insertChildIdea();
      }
    }
  } else if (this.url != null) {
    return window.open(this.url, "_blank");
  } else if (this.goto != null) {
    gia = this.goto;
    if (isId(gia)) {
      gia = idea[-gia];
    }
    if (gia.frame != null) {
      return gia.fhtml(gia);
    } else {
      return gia.upperFrame().fhtml(gia);
    }
  } else if (this.frame != null) {
    if (this === fidea) {
      if (this === idea[0]) {
        if (this.length === 0) {
          return insertChildIdea();
        }
      } else {
        return this.upperFrame().fhtml(this);
      }
    } else {
      return this.fhtml();
    }
  } else {
    if (!((this.noenter != null) || (this.readonly != null) || (((_ref1 = this.pa) != null ? _ref1.childreadonly : void 0) != null) || readonly)) {
      if (prevKey === KEY_ENTER) {
        if ((this.pa.intype != null) && this.pa.intype === TABLE && this.sd >= 0) {
          if (this.sd === this.pa.length - 1) {
            ia = insertDownRow();
            if (sidea.list != null) {
              return ia.list = sidea.list;
            }
          } else {
            if (((_ref2 = this.pa[this.sd + 1]) != null ? _ref2[this.ix] : void 0) != null) {
              return this.pa[this.sd + 1][this.ix].select();
            }
          }
        } else {
          ia = insertDownIdea();
          if (sidea.list != null) {
            ia.list = sidea.list;
          }
          return ia.select();
        }
      }
    }
  }
};

keye[DEFAULT][KEY_ENTER] = function() {
  var _ref;
  finishEdit();
  if (!((this.noenter != null) || (this.readonly != null) || (((_ref = this.pa) != null ? _ref.childreadonly : void 0) != null))) {
    if (prevKey === KEY_ENTER) {
      return insertDownIdea();
    }
  }
};

keyp[DEFAULT][SHIFT + KEY_F11] = function() {
  return viewFullScreen();
};

keyp[DEFAULT][KEY_ESC] = function() {
  if (currentModel !== "minday") {
    return selectModel("minday", true);
  } else {
    return viewFullScreen();
  }
};

history = [];

backFlag = false;

backHistory = function() {
  var hi, his;
  if (history.length > 0) {
    hi = history.length - 2;
    while ((!(history[hi] != null)) && hi > 0) {
      hi--;
    }
    if (history[hi] != null) {
      his = history.pop();
      backFlag = true;
      return his.upperFrame().fhtml(his);
    }
  }
};

saveHistory = function() {
  if (!backFlag) {
    history.push(sidea);
  }
  return backFlag = false;
};

keyp[DEFAULT][ALT + KEY_BACKSPACE] = function() {
  return backHistory();
};

keyp[BUTTON] = {};

keyp[BUTTON][KEY_ENTER] = function() {
  if (this.run != null) {
    this.run();
  }
  if (this.goto != null) {
    return this.goto.upperFrame().fhtml(this.goto);
  }
};

ideaClick = function(eo) {
  var id;
  id = this.data("id");
  alert(id);
  finishEdit();
  idea[id].select();
  if (id === sidea.id) {
    startEdit();
  }
  return eo.preventDefault();
};

keyp[DEFAULT][CTRL + KEY_HOME] = function() {
  return idea[0].fhtml();
};

keyp[DEFAULT][ALT + KEY_F1] = function() {
  if (currentModel === "minday") {
    updateModel("minday", fidea, sidea);
  }
  return selectModel("help-interface", true);
};
