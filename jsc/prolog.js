// Generated by CoffeeScript 1.3.3
﻿;

var Atom, BagOf, BagOfCollectFunction, Body, Call, Comparitor, Cut, Eq, EvalContext, External, ExternalAndParse, Fail, Ne, ParseBody, ParseHead, ParsePart, ParseRule, ParseTerm, Partlist, Rule, Term, Tokeniser, Variable, addfact, addrule, answer, applyOne, currenttoken, factsProlog, newEnv, print, printVars, provalue, prove, renameVariables, rules, runProlog, sout, tokenstring, unify, varNames;

rules = [];

addfact = function(fact) {
  return add(fact, {
    kind: FACT
  });
};

addrule = function(rule) {
  rules.push(rule);
  return add(rule, {
    kind: RULE
  });
};

factsProlog = function() {
  var a, ia, k, s, v, _i, _len, _results;
  _results = [];
  for (_i = 0, _len = idea.length; _i < _len; _i++) {
    ia = idea[_i];
    if (ia.kind === FACT) {
      if (ia.length > 0) {
        s = "#" + (-ia.id);
        s += "(" + ((function() {
          var _j, _len1, _ref, _results1;
          _ref = ia.data;
          _results1 = [];
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            a = _ref[_j];
            _results1.push("#" + (-a.id));
          }
          return _results1;
        })()).join(",") + ")";
        s += ". ";
        rules.push(s);
      }
      _results.push((function() {
        var _ref, _results1;
        _ref = ia.prop;
        _results1 = [];
        for (k in _ref) {
          v = _ref[k];
          _results1.push((function() {
            var _j, _len1, _results2;
            _results2 = [];
            for (_j = 0, _len1 = v.length; _j < _len1; _j++) {
              a = v[_j];
              s = "#" + (-Number(k)) + "(#" + (-ia.id);
              s += ",#" + (-a.id);
              s += "). ";
              _results2.push(rules.push(s));
            }
            return _results2;
          })());
        }
        return _results1;
      })());
    } else {
      _results.push(void 0);
    }
  }
  return _results;
};

sout = "";

answer = [];

print = function(str) {
  return sout += str;
};

applyOne = function(f, arg1) {
  return function(arg2) {
    return f(arg1, arg2);
  };
};

printVars = function(which, environment) {
  var answ, i, sv;
  if (which.length === 0) {
    print("Правда.");
    answ = [['', 'Правда']];
    answer.push(answ);
  } else {
    i = 0;
    answ = [];
    while (i < which.length) {
      sv = (provalue(new Variable(which[i].name + ".0"), environment)).print();
      if (sv[0] === "#") {
        sv = idea[sv.substr(1)].txt;
      }
      answ.push([which[i].name, sv]);
      i++;
    }
    answer.push(answ);
  }
  return print("\n");
};

provalue = function(x, env) {
  var binding, i, l;
  if (x.type === "Term") {
    l = [];
    i = 0;
    while (i < x.partlist.list.length) {
      l[i] = provalue(x.partlist.list[i], env);
      i++;
    }
    return new Term(x.name, l);
  }
  if (x.type !== "Variable") {
    return x;
  }
  binding = env[x.name];
  if (binding == null) {
    return x;
  }
  return provalue(binding, env);
};

newEnv = function(n, z, e) {
  var i, ne;
  ne = [];
  ne[n] = z;
  for (i in e) {
    if (i !== n) {
      ne[i] = e[i];
    }
  }
  return ne;
};

unify = function(x, y, env) {
  var i;
  x = provalue(x, env);
  y = provalue(y, env);
  if (x.type === "Variable") {
    return newEnv(x.name, y, env);
  }
  if (y.type === "Variable") {
    return newEnv(y.name, x, env);
  }
  if (x.type === "Atom" || y.type === "Atom") {
    if (x.type === y.type && x.name === y.name) {
      return env;
    } else {
      return null;
    }
  }
  if (x.name !== y.name) {
    return null;
  }
  if (x.partlist.list.length !== y.partlist.list.length) {
    return null;
  }
  i = 0;
  while (i < x.partlist.list.length) {
    env = unify(x.partlist.list[i], y.partlist.list[i], env);
    if (env == null) {
      return null;
    }
    i++;
  }
  return env;
};

renameVariables = function(list, level, parent) {
  var i, out;
  out = [];
  if (list.type === "Atom") {
    return list;
  } else if (list.type === "Variable") {
    return new Variable(list.name + "." + level);
  } else if (list.type === "Term") {
    out = new Term(list.name, renameVariables(list.partlist.list, level, parent));
    out.parent = parent;
    return out;
  }
  i = 0;
  while (i < list.length) {
    out[i] = renameVariables(list[i], level, parent);
    i++;
  }
  return out;
};

varNames = function(list) {
  var i, innercont, j, k, maincont, o2, out;
  out = [];
  maincont = void 0;
  innercont = void 0;
  i = 0;
  while (i < list.length) {
    maincont = true;
    if (list[i].type === "Variable") {
      j = 0;
      while (j < out.length) {
        if (out[j].name === list[i].name) {
          maincont = false;
        }
        j++;
      }
      if (maincont) {
        out[out.length] = list[i];
      }
    } else if (list[i].type === "Term") {
      o2 = varNames(list[i].partlist.list);
      j = 0;
      while (j < o2.length) {
        innercont = true;
        k = 0;
        while (k < out.length) {
          if (o2[j].name === out[k].name) {
            innercont = false;
          }
          k++;
        }
        if (innercont) {
          out[out.length] = o2[j];
        }
        j++;
      }
    }
    i++;
  }
  return out;
};

prove = function(goalList, environment, db, level, reportFunction) {
  var body, builtin, env2, i, j, k, newFirstGoals, newGoals, provestop, renamedHead, ret, rule, thisTerm;
  if (goalList.length === 0) {
    reportFunction(environment);
    return null;
  }
  thisTerm = goalList[0];
  builtin = db.builtin[thisTerm.name + "/" + thisTerm.partlist.list.length];
  if (builtin) {
    newGoals = [];
    j = 1;
    while (j < goalList.length) {
      newGoals[j - 1] = goalList[j];
      j++;
    }
    return builtin(thisTerm, newGoals, environment, db, level + 1, reportFunction);
  }
  i = 0;
  provestop = false;
  while (i < db.length && !provestop) {
    if (thisTerm.excludeRule !== i) {
      rule = db[i];
      if (rule.head.name === thisTerm.name) {
        renamedHead = new Term(rule.head.name, renameVariables(rule.head.partlist.list, level, thisTerm));
        env2 = unify(thisTerm, renamedHead, environment);
        if (env2 != null) {
          body = rule.body;
          if (body != null) {
            newFirstGoals = renameVariables(rule.body.list, level, renamedHead);
            newGoals = [];
            j = 0;
            while (j < newFirstGoals.length) {
              newGoals[j] = newFirstGoals[j];
              if (rule.body.list[j].excludeThis) {
                newGoals[j].excludeRule = i;
              }
              j++;
            }
            k = 1;
            while (k < goalList.length) {
              newGoals[j++] = goalList[k];
              k++;
            }
            ret = prove(newGoals, env2, db, level + 1, reportFunction);
            if (ret != null) {
              return ret;
            }
          } else {
            newGoals = [];
            j = 1;
            while (j < goalList.length) {
              newGoals[j - 1] = goalList[j];
              j++;
            }
            ret = prove(newGoals, env2, db, level + 1, reportFunction);
            if (ret != null) {
              return ret;
            }
          }
          if (renamedHead.cut) {
            provestop = true;
          }
          if (thisTerm.parent.cut) {
            provestop = true;
          }
        }
      }
    }
    i++;
  }
  return null;
};

Variable = function(head) {
  this.name = head;
  this.print = function() {
    return this.name;
  };
  return this.type = "Variable";
};

Atom = function(head) {
  this.name = head;
  this.print = function() {
    return this.name;
  };
  return this.type = "Atom";
};

Term = function(head, list) {
  this.name = head;
  this.partlist = new Partlist(list);
  this.print = function() {
    var com, prs, x;
    prs = "";
    if (this.name === "cons") {
      x = this;
      while (x.type === "Term" && x.name === "cons" && x.partlist.list.length === 2) {
        x = x.partlist.list[1];
      }
      if ((x.type === "Atom" && x.name === "nil") || x.type === "Variable") {
        x = this;
        prs += "[";
        com = false;
        while (x.type === "Term" && x.name === "cons" && x.partlist.list.length === 2) {
          if (com) {
            prs += ", ";
          }
          prs += x.partlist.list[0].print();
          com = true;
          x = x.partlist.list[1];
        }
        if (x.type === "Variable") {
          prs += " | ";
          prs += x.print();
        }
        prs += "]";
        return prs;
      }
    }
    prs += "" + this.name + "(";
    this.partlist.print();
    prs += ")";
    return prs;
  };
  return this.type = "Term";
};

Partlist = function(list) {
  this.list = list;
  this.print = function() {
    var i, prs;
    prs = "";
    i = 0;
    while (i < this.list.length) {
      prs += this.list[i].print();
      if (i < this.list.length - 1) {
        prs += ", ";
      }
      i++;
    }
    return prs;
  };
  return this;
};

Body = function(list) {
  this.list = list;
  this.print = function() {
    var i, prs;
    prs = "";
    i = 0;
    while (i < this.list.length) {
      prs += this.list[i].print();
      if (i < this.list.length - 1) {
        prs += ", ";
      }
      i++;
    }
    return prs;
  };
  return this;
};

Rule = function(head, bodylist) {
  this.head = head;
  if (bodylist != null) {
    this.body = new Body(bodylist);
  } else {
    this.body = null;
  }
  this.print = function() {
    var prs;
    prs = "";
    if (this.body == null) {
      prs += this.head.print();
      prs += ".\n";
    } else {
      prs += this.head.print();
      prs += " :- ";
      prs += this.body.print();
      prs += ".\n";
    }
    return prs;
  };
  return this;
};

Tokeniser = function(str) {
  this.remainder = str;
  this.current = null;
  this.type = null;
  this.consume = function() {
    var pos, r, ref;
    if (this.type === "eof") {
      return;
    }
    r = this.remainder.match(/^\s*(.*)$/);
    if (r) {
      this.remainder = r[1];
    }
    if (this.remainder === "") {
      this.current = null;
      this.type = "eof";
      return;
    }
    r = this.remainder.match(/^([\(\)\.,\[\]\|\!]|\:\-)(.*)$/);
    if (r) {
      this.remainder = r[2];
      this.current = r[1];
      this.type = "punc";
      return;
    }
    r = this.remainder.match(/^([A-Z_][a-zA-Z0-9_]*)(.*)$/);
    if (r) {
      this.remainder = r[2];
      this.current = r[1];
      ref = find(this.current);
      if (ref != null) {
        this.current = "#" + (-ref.id);
      }
      this.type = "var";
      return;
    }
    r = this.remainder.match(/^(\{[^\}]*\})(.*)$/);
    if (r) {
      this.remainder = r[2];
      this.current = r[1];
      this.type = "id";
      return;
    }
    r = this.remainder.match(/^("[^"]*")(.*)$/);
    if (r) {
      this.remainder = r[2];
      this.current = r[1];
      this.type = "id";
      return;
    }
    r = this.remainder.match(/^([a-zA-Z0-9][a-zA-Z0-9_]*)(.*)$/);
    if (r) {
      this.remainder = r[2];
      this.current = r[1];
      ref = find(this.current);
      if (ref != null) {
        this.current = "#" + (-ref.id);
      }
      this.type = "id";
      return;
    }
    r = this.remainder.match(/^([А-Я_][а-яА-Я0-9_]*)(.*)$/);
    if (r) {
      this.remainder = r[2];
      this.current = r[1];
      ref = find(this.current);
      if (ref != null) {
        this.current = "#" + (-ref.id);
      }
      this.type = "var";
      return;
    }
    r = this.remainder.match(/^([а-яА-Я0-9][а-яА-Я0-9_]*)(.*)$/);
    if (r) {
      this.remainder = r[2];
      this.current = r[1];
      ref = find(this.current);
      if (ref != null) {
        this.current = "#" + (-ref.id);
      }
      this.type = "id";
      return;
    }
    r = this.remainder.match(/^([#][0-9]*)(.*)$/);
    if (r) {
      this.remainder = r[2];
      this.current = r[1];
      this.type = "id";
      return;
    }
    if ((this.remainder != null) && this.remainder[0] === "'" || this.remainder[0] === '"') {
      pos = 1;
      while (pos < this.remainder.length && this.remainder[pos] !== this.remainder[0]) {
        pos++;
      }
      if (pos > 0) {
        this.current = this.remainder.substr(1, pos - 1);
        this.remainder = this.remainder.substr(pos + 1);
        ref = find(this.current);
        if (ref != null) {
          this.current = "#" + (-ref.id);
        }
        this.type = "id";
        return;
      }
    }
    /*				
    			r = @remainder.match(/^([\'].*[\'])(.*)$/)  # Строки
    			if r
    				if r[1]
    				@remainder = r[2]
    				@current = r[1].substr(1).slice(0,-1)
    				# Проверим, нет ли в базе?
    				ref = find(r[1].substr(1).slice(0,-1))
    				if ref? then @current = "#"+Math.abs(ref)
    				@type = "id"
    				console.log @current
    				return
    			r = @remainder.match(/^([\"].*[\"])(.*)$/)  # Строки
    			if r
    				@remainder = r[2]
    				@current = r[1].substr(1).slice(0,-1)
    				# Проверим, нет ли в базе?
    				ref = find(r[1].substr(1).slice(0,-1))
    				if ref? then @current = "#"+Math.abs(ref)
    				@type = "id"
    				return
    */

    r = this.remainder.match(/^(-[0-9][0-9]*)(.*)$/);
    if (r) {
      this.remainder = r[2];
      this.current = r[1];
      this.type = "id";
      return;
    }
    this.current = null;
    return this.type = "eof";
  };
  return this.consume();
};

tokenstring = "";

currenttoken = "";

ParseRule = function(tk) {
  var b, h;
  h = ParseHead(tk);
  if (!h) {
    return null;
  }
  if (tk.current === ".") {
    return new Rule(h, null);
  }
  if (tk.current !== ":-") {
    return null;
  }
  tk.consume();
  b = ParseBody(tk);
  if (tk.current !== ".") {
    return null;
  }
  return new Rule(h, b);
};

ParseHead = function(tk) {
  return ParseTerm(tk);
};

ParseTerm = function(tk) {
  var i, name, notthis, p, part, term;
  if (tk.type === "punc" && tk.current === "!") {
    tk.consume();
    return new Term("cut", []);
  }
  notthis = false;
  if (tk.current === "NOTTHIS") {
    notthis = true;
    tk.consume();
  }
  if (tk.type !== "id") {
    return null;
  }
  name = tk.current;
  tk.consume();
  if (tk.current !== "(") {
    if (name === "fail") {
      return new Term(name, []);
    }
    return null;
  }
  tk.consume();
  p = [];
  i = 0;
  while (tk.current !== ")") {
    if (tk.type === "eof") {
      return null;
    }
    part = ParsePart(tk);
    if (part == null) {
      return null;
    }
    if (tk.current === ",") {
      tk.consume();
    } else {
      if (tk.current !== ")") {
        return null;
      }
    }
    p[i++] = part;
  }
  tk.consume();
  term = new Term(name, p);
  if (notthis) {
    term.excludeThis = true;
  }
  return term;
};

ParsePart = function(tk) {
  var append, i, l, n, name, p, part, t;
  if (tk.type === "var") {
    n = tk.current;
    tk.consume();
    return new Variable(n);
  }
  if (tk.type !== "id") {
    if (tk.type !== "punc" || tk.current !== "[") {
      return null;
    }
    tk.consume();
    if (tk.type === "punc" && tk.current === "]") {
      tk.consume();
      return new Atom("nil");
    }
    l = [];
    i = 0;
    while (true) {
      t = ParsePart(tk);
      if (t == null) {
        return null;
      }
      l[i++] = t;
      if (tk.current !== ",") {
        break;
      }
      tk.consume();
    }
    append = void 0;
    if (tk.current === "|") {
      tk.consume();
      if (tk.type !== "var") {
        return null;
      }
      append = new Variable(tk.current);
      tk.consume();
    } else {
      append = new Atom("nil");
    }
    if (tk.current !== "]") {
      return null;
    }
    tk.consume();
    --i;
    while (i >= 0) {
      append = new Term("cons", [l[i], append]);
      i--;
    }
    return append;
  }
  name = tk.current;
  tk.consume();
  if (tk.current !== "(") {
    return new Atom(name);
  }
  tk.consume();
  p = [];
  i = 0;
  while (tk.current !== ")") {
    if (tk.type === "eof") {
      return null;
    }
    part = ParsePart(tk);
    if (part == null) {
      return null;
    }
    if (tk.current === ",") {
      tk.consume();
    } else {
      if (tk.current !== ")") {
        return null;
      }
    }
    p[i++] = part;
  }
  tk.consume();
  return new Term(name, p);
};

ParseBody = function(tk) {
  var i, p, t;
  p = [];
  i = 0;
  t = void 0;
  while ((t = ParseTerm(tk)) != null) {
    p[i++] = t;
    if (tk.current !== ",") {
      break;
    }
    tk.consume();
  }
  if (i === 0) {
    return null;
  }
  return p;
};

Eq = function(thisTerm, goalList, environment, db, level, reportFunction) {
  var first, second;
  first = provalue(thisTerm.partlist.list[0], environment);
  if (first.type !== "Atom") {
    return null;
  }
  second = provalue(thisTerm.partlist.list[1], environment);
  if (second.type !== "Atom") {
    return null;
  }
  if (first.name !== second.name) {
    return null;
  }
  return prove(goalList, environment, db, level + 1, reportFunction);
};

Ne = function(thisTerm, goalList, environment, db, level, reportFunction) {
  var first, second;
  first = provalue(thisTerm.partlist.list[0], environment);
  if (first.type !== "Atom") {
    return null;
  }
  second = provalue(thisTerm.partlist.list[1], environment);
  if (second.type !== "Atom") {
    return null;
  }
  if (first.name === second.name) {
    return null;
  }
  return prove(goalList, environment, db, level + 1, reportFunction);
};

Comparitor = function(thisTerm, goalList, environment, db, level, reportFunction) {
  var cmp, env2, first, second;
  first = provalue(thisTerm.partlist.list[0], environment);
  if (first.type !== "Atom") {
    return null;
  }
  second = provalue(thisTerm.partlist.list[1], environment);
  if (second.type !== "Atom") {
    return null;
  }
  cmp = "eq";
  if (first.name < second.name) {
    cmp = "lt";
  } else {
    if (first.name > second.name) {
      cmp = "gt";
    }
  }
  env2 = unify(thisTerm.partlist.list[2], new Atom(cmp), environment);
  if (env2 == null) {
    return null;
  }
  return prove(goalList, env2, db, level + 1, reportFunction);
};

Cut = function(thisTerm, goalList, environment, db, level, reportFunction) {
  var ret;
  ret = prove(goalList, environment, db, level + 1, reportFunction);
  thisTerm.parent.cut = true;
  return ret;
};

Call = function(thisTerm, goalList, environment, db, level, reportFunction) {
  var first, j, newGoals;
  first = provalue(thisTerm.partlist.list[0], environment);
  if (first.type !== "Term") {
    return null;
  }
  newGoals = [];
  newGoals[0] = first;
  first.parent = thisTerm;
  j = 0;
  while (j < goalList.length) {
    newGoals[j + 1] = goalList[j];
    j++;
  }
  return prove(newGoals, environment, db, level + 1, reportFunction);
};

Fail = function(thisTerm, goalList, environment, db, level, reportFunction) {
  return null;
};

BagOf = function(thisTerm, goalList, environment, db, level, reportFunction) {
  var anslist, answers, collect, env2, i, into, newGoal, newGoals, ret, subgoal;
  collect = provalue(thisTerm.partlist.list[0], environment);
  subgoal = provalue(thisTerm.partlist.list[1], environment);
  into = provalue(thisTerm.partlist.list[2], environment);
  collect = renameVariables(collect, level, thisTerm);
  newGoal = new Term(subgoal.name, renameVariables(subgoal.partlist.list, level, thisTerm));
  newGoal.parent = thisTerm;
  newGoals = [];
  newGoals[0] = newGoal;
  anslist = [];
  anslist.renumber = -1;
  ret = prove(newGoals, environment, db, level + 1, BagOfCollectFunction(collect, anslist));
  answers = new Atom("nil");
  i = anslist.length;
  while (i > 0) {
    answers = new Term("cons", [anslist[i - 1], answers]);
    i--;
  }
  env2 = unify(into, answers, environment);
  if (env2 == null) {
    return null;
  }
  return prove(goalList, env2, db, level + 1, reportFunction);
};

BagOfCollectFunction = function(collect, anslist) {
  return function(env) {
    return anslist[anslist.length] = renameVariables(provalue(collect, env), anslist.renumber--, []);
  };
};

EvalContext = [];

External = function(thisTerm, goalList, environment, db, level, reportFunction) {
  var arg, arglist, env2, first, i, r, re, ret, second;
  first = provalue(thisTerm.partlist.list[0], environment);
  if (first.type !== "Atom") {
    return null;
  }
  r = first.name.match(/^"(.*)"$/);
  if (!r) {
    return null;
  }
  r = r[1];
  second = provalue(thisTerm.partlist.list[1], environment);
  arglist = [];
  i = 1;
  while (second.type === "Term" && second.name === "cons") {
    arg = provalue(second.partlist.list[0], environment);
    if (arg.type !== "Atom") {
      return null;
    }
    re = new RegExp("\\$" + i, "g");
    r = r.replace(re, arg.name);
    second = second.partlist.list[1];
    i++;
  }
  if (second.type !== "Atom" || second.name !== "nil") {
    return null;
  }
  ret = eval(r);
  if (!ret) {
    ret = "nil";
  }
  env2 = unify(thisTerm.partlist.list[2], new Atom(ret), environment);
  if (env2 == null) {
    return null;
  }
  return prove(goalList, env2, db, level + 1, reportFunction);
};

ExternalAndParse = function(thisTerm, goalList, environment, db, level, reportFunction) {
  var arg, arglist, env2, first, i, r, re, ret, second;
  first = provalue(thisTerm.partlist.list[0], environment);
  if (first.type !== "Atom") {
    return null;
  }
  r = first.name.match(/^"(.*)"$/);
  if (!r) {
    return null;
  }
  r = r[1];
  second = provalue(thisTerm.partlist.list[1], environment);
  arglist = [];
  i = 1;
  while (second.type === "Term" && second.name === "cons") {
    arg = provalue(second.partlist.list[0], environment);
    if (arg.type !== "Atom") {
      return null;
    }
    re = new RegExp("\\$" + i, "g");
    r = r.replace(re, arg.name);
    second = second.partlist.list[1];
    i++;
  }
  if (second.type !== "Atom" || second.name !== "nil") {
    return null;
  }
  ret = eval(r);
  if (!ret) {
    ret = "nil";
  }
  ret = ParsePart(new Tokeniser(ret));
  env2 = unify(thisTerm.partlist.list[2], ret, environment);
  if (env2 == null) {
    return null;
  }
  return prove(goalList, env2, db, level + 1, reportFunction);
};

runProlog = function(query) {
  var outi, outr, q, r, vs;
  outr = [];
  outi = 0;
  r = 0;
  while (r < rules.length) {
    outr[outi++] = ParseRule(new Tokeniser(rules[r]));
    r++;
  }
  outr.builtin = [];
  outr.builtin["compare/3"] = Comparitor;
  outr.builtin["cut/0"] = Cut;
  outr.builtin["call/1"] = Call;
  outr.builtin["fail/0"] = Fail;
  outr.builtin["bagof/3"] = BagOf;
  outr.builtin["external/3"] = External;
  outr.builtin["external2/3"] = ExternalAndParse;
  outr.builtin["eq/2"] = Eq;
  outr.builtin["ne/2"] = Ne;
  q = ParseBody(new Tokeniser(query));
  if (q == null) {
    print("An error occurred parsing the query.\n");
    return;
  }
  q = new Body(q);
  vs = varNames(q.list);
  prove(renameVariables(q.list, 0, []), [], outr, 1, applyOne(printVars, vs));
  return answer;
};
