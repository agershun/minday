// Generated by CoffeeScript 1.3.3

canvastype[BCG] = function() {
  return ACTIVE;
};

childkind[BCG] = function() {
  return BCGENTITY;
};

keyp[BCG] = {};

keyp[BCGENTITY] = {};

Idea.prototype.kindBCG = function() {
  var i, ia, r, ra, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2, _ref3, _ref4;
  this.kind = BCG;
  this.row.kind = BCGROWS;
  this.row.pa = this;
  this.row.ix = "row";
  this.column.kind = BCGCOLUMNS;
  this.column.pa = this;
  this.column.ix = "column";
  if (this.row != null) {
    _ref = this.row.data;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      ia = _ref[i];
      ia.kind = BCGROW;
      ia.pa = this.row;
      ia.ix = i;
    }
  }
  if (this.column != null) {
    _ref1 = this.column.data;
    for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
      ia = _ref1[i];
      ia.kind = BCGCOLUMN;
      ia.pa = this.column;
      ia.ix = i;
    }
  }
  _ref2 = this.data;
  for (r = _k = 0, _len2 = _ref2.length; _k < _len2; r = ++_k) {
    ra = _ref2[r];
    ra.kind = BCGROWCELL;
    ra.pa = this;
    ra.ix = r;
    _ref3 = ra.data;
    for (i = _l = 0, _len3 = _ref3.length; _l < _len3; i = ++_l) {
      ia = _ref3[i];
      ra.kind = BCGCELL;
      ra.pa = this;
      ra.ix = i;
    }
  }
  _ref4 = this.entity.data;
  for (i = _m = 0, _len4 = _ref4.length; _m < _len4; i = ++_m) {
    ia = _ref4[i];
    ia.kind = BCGENTITY;
    ia.pa = this;
    ia.ix = i;
  }
  return this;
};

draw[BCGCOLUMNS] = function(level) {
  return this.simpleIdeaTxt(level);
};

draw[BCGROWS] = function(level) {
  return this.simpleIdeaTxt(level);
};

draw[BCG] = function(level) {
  var ca, ra, ri, s, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
  s = this.startIdeaTxt(level);
  if ((level === 0) || (level > 0 && !(this.frame != null))) {
    cvva.push(this);
    s += "<div style='position:relative'>";
    s += "<div id='bcg" + this.id + "'  class='bcgbag' style='position:absolute;top:0px;left:0px;vertical-align:bottom'>";
    s += "<table id='bag" + this.id + "'>";
    if (this.column != null) {
      s += "<thead>";
      s += "<tr>";
      if (this.row != null) {
        s += "<th>";
        s += "</th>";
        s += "<th>";
        s += "</th>";
      }
      s += "<th id='tbl" + this.column.id + "' colspan=" + this.column.length + " style='text-align:center;'>";
      s += this.column.draw(level + 1);
      s += "</th>";
      s += "</tr>";
      s += "<tr>";
      if (this.row != null) {
        s += "<th>";
        s += "</th>";
        s += "<th>";
        s += "</th>";
      }
      _ref = this.column;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        ca = _ref[_i];
        s += "<th id='tbl" + ca.id + "'>";
        s += ca.draw(level + 1);
        s += "</th>";
      }
      s += "</thead>";
    }
    _ref1 = this.data;
    for (ri = _j = 0, _len1 = _ref1.length; _j < _len1; ri = ++_j) {
      ra = _ref1[ri];
      s += "<tr>";
      if (this.row != null) {
        if (ri === 0) {
          s += "<th id='tbl" + this.row.id + "' rowspan=" + this.row.length + " style=''>";
          s += this.row.draw(level + 1);
          s += "</th>";
        }
        s += "<th id='tbl" + this.row[ri].id + "'>";
        s += this.row[ri].draw(level + 1);
        s += "</th>";
      }
      for (_k = 0, _len2 = ra.length; _k < _len2; _k++) {
        ca = ra[_k];
        s += "<td id='tbl" + ca.id + "'>";
        s += ca.draw(level + 1);
        s += "</td>";
      }
      s += "</tr>";
    }
    s += "</table>";
    s += "</div>";
    s += "<div style='position:absolute;top:0px;left:0px'>";
  }
  s += this.endIdeaTxt(level);
  return s;
};

shape[BCGENTITY] = function(x, y, w, h) {
  var s;
  return s = "M " + x + " " + y + "				m " + (-w / 2) + " 0 a " + (w / 2) + " " + (h / 2) + " 0 0 0 " + w + " 0 a " + (w / 2) + " " + (h / 2) + " 0 0 0 " + (-w) + " 0 z";
};

svg[BCG] = function(level) {
  var ie, _i, _len, _ref, _results;
  console.log($("#bcg" + this.id).outerWidth(true), $("#bcg" + this.id).outerHeight(true));
  ppr[this.id] = Raphael("pap" + this.id, $("#bcg" + this.id).outerWidth(true), $("#bcg" + this.id).outerHeight(true));
  v[this.id] = {};
  v[this.id].ppr = ppr[this.id];
  v[this.id].ww = $("#bcg" + this.id).outerWidth(true);
  v[this.id].hh = $("#bcg" + this.id).outerHeight(true);
  v[this.id].sw = $("#tbl" + this.row.id).outerWidth(true) + $("#tbl" + this.row[0].id).outerWidth(true);
  v[this.id].sh = $("#tbl" + this.column.id).outerHeight(true) + $("#tbl" + this.column[0].id).outerHeight(true);
  console.log(v[this.id].sh, v[this.id].hh);
  v[this.id].w = v[this.id].ww - v[this.id].sw;
  v[this.id].h = v[this.id].hh - v[this.id].sh;
  _ref = this.entity;
  _results = [];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    ie = _ref[_i];
    v[ie.id] = {};
    v[ie.id].ppr = ppr[this.id];
    v[ie.id].x = ie.x * v[this.id].w + v[this.id].sw;
    v[ie.id].y = ie.y * v[this.id].h + v[this.id].sh;
    v[ie.id].w = ie.r * v[this.id].w;
    v[ie.id].h = ie.r * v[this.id].h;
    _results.push(ie.bcgdraw());
  }
  return _results;
};

Idea.prototype.bcgdraw = function() {
  if (g[this.id] != null) {

  } else {
    g[this.id] = v[this.id].ppr.path(this.shape(v[this.id].x, v[this.id].y, v[this.id].w, v[this.id].h));
    g[this.id].attr({
      "stroke": "#888",
      "stroke-opacity": 0.5,
      "stroke-width": 1,
      "fill": "90-#FF9-#FFE",
      "fill-opacity": 1
    });
    g[this.id].data("id", this.id);
    g[this.id].click(ideaClick);
    $("#bag" + this.id).css("position", "absolute");
    $("#bag" + this.id).css("top", v[this.id].y - v[this.id].h / 2);
    return $("#bag" + this.id).css("left", v[this.id].x - v[this.id].w / 2);
  }
};

childkind[BCGCELL] = function() {
  return IDEA;
};

childkind[BCGROW] = function() {
  return IDEA;
};

childkind[BCGCOLUMN] = function() {
  return IDEA;
};

childkind[BCGROWS] = function() {
  return BCGROW;
};

childkind[BCGCOLUMNS] = function() {
  return BCGCOLUMNS;
};

childkind[BCGENTITY] = function() {
  return null;
};

keyp[BCG] = {};

keyp[BCGROWS] = {};

keyp[BCGROW] = {};

keyp[BCGCOLUMNS] = {};

keyp[BCGCOLUMN] = {};

keyp[BCGCELL] = {};

keyp[BCGENTITY] = {};
